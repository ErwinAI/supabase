---
id: 'authorization'
title: 'Realtime Authorization'
description: 'Authorization for Supabase Realtime'
sidebar_label: 'Authorization'
---

You can control client access to Realtime [Broadcast](/docs/guides/realtime/broadcast) and [Presence](/docs/guides/realtime/presence) by adding Row Level Security policies to the `realtime.messages` table. Each RLS policy can map to a specific action a client can take:

- Control which clients can broadcast to a Channel
- Control which clients can receive broadcasts from a Channel
- Control which clients can publish their presence to a Channel
- Control which clients can receive messages about the presence of other clients

<Admonition type="caution">

Realtime Authorization is in Public Alpha. To use Authorization for your Realtime Channels, use `supabase-js` version `v2.44.0` or later.

</Admonition>

## How it works

Realtime uses the `messages` table in your database's `realtime` schema to generate access policies for your clients when they connect to a Channel topic.

By creating RLS polices on the `realtime.messages` table you can control the access users have to a Channel topic, and features within a Channel topic,

The validation is done when the user connects. When their WebSocket connection is established and a Channel topic is joined, their permissions are calculated based on:

- The RLS policies on tables in your `realtime` schema
- The user information sent as part of their [Auth JWT](/docs/guides/auth/jwts)
- The request headers
- The Channel topic the user is trying to connect to

Using Realtime authorization involves two steps:

- In your database, create an RLS policy on `realtime.messages`
- In your client, instantiate the Realtime Channel with the `config` option `private: true`

<Admonition type="caution">

Increased RLS complexity can impact database performance and connection time, leading to higher connection latency and decreased join rates.

</Admonition>

## Helper functions

You can use the following helper functions when writing RLS policies:

### `realtime.topic`

Returns the Channel topic the user is attempting to connect to.

```sql
create policy "authenticated users can read all messages in room_1"
on "realtime"."messages"
for select
to authenticated
using (
  (select realtime.topic()) = 'room_1'
);
```

## Examples

The following examples use this schema:

```sql
create table public.profiles (
  email text not null,
  user_id uuid references auth.users (id)
);

create table public.rooms_users (
  topic text references realtime.messages (topic),
  user_id uuid references auth.users (id),
  created_at timestamptz default current_timestamp
);

// Trigger to populate profiles table
create or replace function insert_user () returns trigger as
$$
  begin
    insert into public.profiles (user_id, email) values (new.id, new.email);
    return new;
  end;
$$ language plpgsql;

create or replace trigger "on_new_auth_create_profile"
after insert on auth.users for each row
execute function insert_user ();

revoke execute on function insert_user () from public, anon, authenticated;
grant execute on function insert_user () to supabase_auth_admin;
grant insert on table public.profiles to supabase_auth_admin;
```

### Broadcast

The `extension` field on the `realtime.messages` table records the message type. For Broadcast messages, the value of `realtime.messages.extension` is `broadcast`. You can check for this in your RLS policies.

#### Allow a user to join (and read) a Broadcast topic

To join a Broadcast Channel, a user must have at least one read or write permission on the Channel topic.

Here, we allow reads (`select`s) for users who are linked to the requested topic within the relationship table `public.room_users`:

```sql
create policy "authenticated users can join topic"
on "realtime"."messages"
for select
to authenticated
using (
exists (
    select
      ru.user_id
    from
      rooms_users ru
    where
      ru.user_id = (select auth.uid())
      and ru.topic = (select realtime.topic())
      and realtime.messages.extension in ('broadcast')
  )
);
```

Then, to join a topic with RLS enabled, instantiate the Channel with the `private` option set to `true`.

```typescript
import { createClient } from 'npm:@supabase/supabase-js@2.38.5'
const url = 'https://<project_ref>.supabase.com'
const apikey = '<api_key>'

const client = createClient(url, apikey)

const channel = client.channel('room_1', {
  config: { private: true },
})

channel
  .on('broadcast', { event: 'test' }, (payload) => console.log(payload))
  .subscribe((status: string, err: any) => {
    if (status === 'SUBSCRIBED') {
      console.log('Connected!')
    } else {
      console.error(err)
    }
  })
```

#### Allow a user to send a Broadcast message

To authorize sending Broadcast messages, create a policy for `insert` where the value of `realtime.messages.extension` is `broadcast`.

Here, we allow writes (sends) for users who are linked to the requested topic within the relationship table `public.room_users`:

```sql
create policy "authenticated users can send broadcast messages in a room"
on "realtime"."messages"
for insert
to authenticated
with check (
  exists (
    select
      ru.user_id
    from
      rooms_users ru
    where
      ru.user_id = (select auth.uid())
      and ru.topic = (select realtime.topic())
      and realtime.messages.extension in ('broadcast')
  )
);
```

### Presence

The `extension` field on the `realtime.messages` table records the message type. For Presence messages, the value of `realtime.messages.extension` is `presence`. You can check for this in your RLS policies.

#### Allow users to listen to Presence messages on a Channel

Create a policy for `select` on `realtime.messages` where `realtime.messages.extension` is `presence`.

```sql
create policy "authenticated users can listen to presence changes in a room"
on "realtime"."messages"
for select
to authenticated
using (
  exists (
    select
      ru.user_id
    from
      rooms_users ru
    where
      ru.user_id = (select auth.uid())
      and ru.topic = (select realtime.topic())
      and realtime.messages.extension in ('presence')
  )
);
```

#### Allow users to send Presence messages on a channel

To update the Presence status for a user create a policy for `insert` on `realtime.messages` where the value of `realtime.messages.extension` is `presence`.

```sql
create policy "authenticated users can register and update their presence in a room"
on "realtime"."messages"
for insert
to authenticated
with check (
  exists (
    select
      ru.user_id
    from
      rooms_users ru
    where
      ru.user_id = (select auth.uid())
      and ru.name = (select realtime.topic())
      and realtime.messages.extension in ('presence')
  )
);
```

### Presence and Broadcast

Authorize both Presence and Broadcast by including both extensions in the `where` filter.

#### Broadcast and Presence read

Authorize Presence and Broadcast read in one RLS policy.

```sql
create policy "authenticated user can listen to Broadcast and Presence messages in room"
on "realtime"."messages"
for select
to authenticated
using (
  exists (
    select
      ru.user_id
    from
      rooms_users ru
    where
      ru.user_id = (select auth.uid())
      and ru.topic = (select realtime.topic())
      and realtime.messages.extension in ('broadcast', 'presence')
  )
);
```

#### Broadcast and Presence write

Authorize Presence and Broadcast write in one RLS policy.

```sql
create policy "authenticated user can send Broadcast and Presence messages in a room"
on "realtime"."messages"
for insert
to authenticated
with check (
  exists (
    select
      ru.user_id
    from
      rooms_users ru
    where
      ru.user_id = (select auth.uid())
      and ru.name = (select realtime.topic())
      and realtime.messages.extension in ('broadcast', 'presence')
  )
);
```

## Interaction with Postgres Changes

Realtime Postgres Changes are separate from Channel authorization. The `private` Channel option does not apply to Postgres Changes.

When using Postgres Changes with RLS, database records are sent only to clients who are allowed to read them based on your RLS policies.

## Updating RLS policies

When you change an RLS policy these changes are picked up when a user connects to a Channel.

When a user connects, Realtime queries your database and generates a representation of the permissions for a user for a Channel.

Permissions are cached for the duration of the connection so we don't have to query your database for each Channel message.

RLS policies are re-checked when access tokens are updated on the Channel. Our client libraries default to updating the access token every 30 seconds.

If a user Channel permissions have been updated these changes will be picked up when the access token is sent over the Channel from the client.

If a new access token is never received on the Channel users will be disconnected when the JWT expires.

Make sure to expire your JWTs frequently.
