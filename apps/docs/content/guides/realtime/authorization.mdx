---
id: 'authorization'
title: 'Realtime Authorization'
description: 'Authorization for Supabase Realtime'
sidebar_label: 'Authorization'
---

In this section we detail how to set up Realtime authorization using RLS policies.

Realtime provides a system to set authorization per user per Channel topic and extension.

<Admonition type="note">

Realtime authorization is in public alpha.

</Admonition>

<Admonition type="note">

Use realtime.js version `2.10.0` or greater.

</Admonition>

## How it works

We use tables in the `realtime` schema to allow you to write RLS policies which will determine the access your users have to a Channel topic and features within a Channel topic.

The validation itself is done on connect per user. For each WebSocket connection we generate the policy for your user based on:

- the RLS policies on tables in your `realtime` schema with the connection context including the JWT
- request headers set on connect
- the Channel topic the user is trying to connect to

<Admonition type="warning">

Increased RLS complexity can impact database performance and connection time, leading to higher connection latency and decreased join rates.

</Admonition>

## Helper functions

We've included a helper function to facilitate building policies.

### realtime.topic

Returns the Channel topic which the user is attempting to connect to.

```sql
CREATE POLICY "authenticated users can read all messages on a topic"
ON "realtime"."messages"
FOR SELECT
TO authenticated
USING (
  realtime.topic = 'room_1'
);
```

## Authorize Channels

Channels serve as our WebSocket representation.

With Realtime authorization we can authorize features within Channel topics or limit joining topics altogether.

### Example schema

Using the following schema for our examples below.

```sql
CREATE TABLE public.profiles (
  email text NOT NULL,
  user_id uuid REFERENCES auth.users (id)
);

CREATE TABLE public.rooms_users (
  topic text REFERENCES realtime.messages (topic),
  user_id uuid REFERENCES auth.users (id),
  created_at timestamptz DEFAULT CURRENT_TIMESTAMP
);

// Trigger to populate profiles table
CREATE OR REPLACE FUNCTION insert_user () RETURNS TRIGGER AS
$$
  BEGIN
    INSERT INTO public.profiles (user_id, email) VALUES (NEW.id, NEW.email); RETURN NEW;
  END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER "on_new_auth_create_profile"
AFTER INSERT ON auth.users FOR EACH ROW
EXECUTE FUNCTION insert_user ();

GRANT EXECUTE ON FUNCTION insert_user () TO supabase_auth_admin;
```

### Authorize Channel joins

To authorize access, clients must have at least one read or write permission on the Channel topic.

Write an RLS policy for `SELECT` and determine which users are able to connect.

Implement the following policy to grant access to the Channel topic exclusively to users listed in the relationship table `public.rooms_users`.

```sql
CREATE POLICY "authenticated users can join topic"
ON "realtime"."messages"
FOR SELECT
TO authenticated
USING (
EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.topic = realtime.topic()
      AND realtime.messages.extension in ['broadcast']
  )
);
```

## Joining Channels

To connect to a Channel and join a topic with RLS enabled, instantiate the Channel with the `private` option set to `true`.

```typescript
import { createClient } from 'npm:@supabase/supabase-js@2.38.5'
const url = 'https://<project_ref>.supabase.com'
const apikey = '<api_key>'

const client = createClient(url, apikey)

const channel = client.channel('room_1', {
  config: { private: true },
})

channel
  .on('broadcast', { event: 'test' }, (payload) => console.log(payload))
  .subscribe((status: string, err: any) => {
    if (status === 'SUBSCRIBED') {
      console.log('Connected!')
    } else {
      console.error(err)
    }
  })
```

## Authorize Broadcast read and write

Broadcast is represented by the `extension` field on the `realtime.messages` table.

If a message is a Broadcast message the value of `realtime.messages.extension` will be `broadcast`.

### Broadcast read

To grant users permission to read Broadcast messages on a Channel topic create a policy for `SELECT` operations on `realtime.messages` where `extension` is `broadcast`.

```sql
CREATE POLICY "authenticated users can receive broadcast messages in a room"
ON "realtime"."messages"
FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.topic = realtime.topic()
      AND realtime.messages.extension in ['broadcast']
  )
);
```

### Broadcast write

To authorize sending Broadcast messages create a policy for `INSERT` where the value of `realtime.messages.extention` is `broadcast`.

```sql
CREATE POLICY "authenticated users can send broadcast messages in a room"
ON "realtime"."messages"
FOR INSERT
TO authenticated
WITH CHECK (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.topic = realtime.topic()
      AND realtime.messages.extension in ['broadcast']
  )
);
```

## Authorize Presence read and write

Presnece is also represented by the `extension` field on the `realtime.messages` table.

If a message is a Presence message the value of `realtime.messages.extension` will be `presence`.

### Presence read

Create a policy for `SELECT` on `realtime.messages` where `realtime.messages.extension` is `presence`.

```sql
CREATE POLICY "authenticated users can listen to presence changes in a room"
ON "realtime"."messages"
FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.topic = realtime.channel_name()
      AND realtime.messages.extension in ['presence']
  )
);
```

### Presence write

To update the Presence status for a user create a policy for `INSERT` on `realtime.messages` where the value of `realtime.messages.extension` is `presence`.

```sql
CREATE POLICY "authenticated users can register and update their presence in a room"
ON "realtime"."messages"
FOR INSERT
TO authenticated
WITH CHECK (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.name = realtime.channel_name()
      AND realtime.messages.extension in ['presence']
  )
);
```

## Authorize Presence and Broadcast

Authorize Presence and Broadcast in two RLS policies by simply including both extensions in our where filter.

### Broadcast and Presence read

Authorize Presence and Broadcast read in one RLS policy.

```sql
CREATE POLICY "authenticated user can listen to Broadcast and Presence messages in room"
ON "realtime"."messages"
FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.topic = realtime.channel_name()
      AND realtime.messages.extension in ['broadcast', 'presence']
  )
);
```

### Broadcast and Presence write

Authorize Presence and Broadcast write in one RLS policy.

```sql
CREATE POLICY "authenticated user can send Broadcast and Presence messages in a room"
ON "realtime"."messages"
FOR INSERT
TO authenticated
WITH CHECK (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.name = realtime.channel_name()
      AND realtime.messages.extension in ['broadcast', 'presence']
  )
);
```

## Avoid usage with Postgres Changes

Realtime Postgres Changes are separate from Channel authorization.

Postgres Changes and Realtime Channl authorization are backwards compatible with your production application.

## Updating RLS policies

When you change an RLS policy these changes are picked up when a user connects to a Channel.

When a user connects, Realtime queries your database and generates a representation of the permissions for a user for a Channel.

Permissions are cached for the duration of the connection so we don't have to query your database for each Channel message.

RLS policies are re-checked when access tokens are updated on the Channel. Our client libraries default to updating the access token every 30 seconds.

If a user Channel permissions have been updated these changes will be picked up when the access token is sent over the Channel from the client.

If a new access token is never received on the Channel users will be disconnected when the JWT expires.

Make sure to expire your JWTs frequently.
