---
id: 'authorization'
title: 'Realtime Authorization'
description: 'Authorization for Supabase Realtime'
sidebar_label: 'Authorization'
---

<Admonition type="note">

Realtime Channels Authorization is in public alpha.

</Admonition>

<Admonition type="note">

Make sure to use the latest version of realtime.js.

</Admonition>

Realtime provides a system to set authorization per Channel and per Channel feature.

In this section we detail how to set up Channel authorization using RLS policies.

## How it works

We use tables in the `realtime` schema to allow you to write RLS policies that will determine the access your users have to your Channel and features within a Channel.

The validation itself is done on connect per each user, meaning that for each WebSocket connection we generate the policy of your user based on:

- the RLS policies you provided with their connection context which will include JWT
- Headers set on connect and
- the Channel the user is trying to connect against

Increased RLS complexity can impact database performance and user connection time, leading to higher connection latency and decreased user join rates.

## Helper functions

We've included a helper function to facilitate building policies, making it easier to access user connection context.

### realtime.topic

Returns the Channel topic to which the user is connecting against.

```sql
CREATE POLICY "authenticated users can view all profiles"
ON "realtime"."messages"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (
  realtime.topic = 'room_1'
);
```

## Authorize Channels

Channels serve as our WebSocket representation, and here, we restrict joining capabilities by preventing WebSocket connections and terminating such connections.

### Example schema

Using the following schema for our examples below.

```sql
CREATE TABLE public.profiles (
  email text NOT NULL,
  user_id uuid REFERENCES auth.users (id)
);
CREATE TABLE public.rooms_users (
  topic text REFERENCES realtime.messages (topic),
  user_id uuid REFERENCES auth.users (id),
  created_at timestamptz DEFAULT CURRENT_TIMESTAMP
);

// Trigger to populate profiles table
CREATE OR REPLACE FUNCTION insert_user () RETURNS TRIGGER AS
$$
  BEGIN
    INSERT INTO public.profiles (user_id, email) VALUES (NEW.id, NEW.email); RETURN NEW;
  END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER "on_new_auth_create_profile"
AFTER INSERT ON auth.users FOR EACH ROW
EXECUTE FUNCTION insert_user ();

GRANT EXECUTE ON FUNCTION insert_user () TO supabase_auth_admin;
```

### Authorize Channel joins

To allow access clients must have at least one read or write permission on the Channel topic.

We'll write an RLS policy for `SELECT` and determine which users are able to connect.

You can implement the following policy to grant access to the Channel topic exclusively to users listed in the relationship table `public.rooms_users`.

```sql
CREATE POLICY "authenticated users can join topic"
ON "realtime"."messages"
FOR SELECT
TO authenticated
USING (
EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.topic = realtime.topic()
      AND realtime.messages.extension in ['broadcast']
  )
);
```

## Joining Channels

To connect to a Channel and join a topic with RLS enabled, instantiate the Channel with the `private` option set to `true`.

```typescript
import { createClient } from 'npm:@supabase/supabase-js@2.38.5'
const url = 'https://<project_ref>.supabase.com'
const apikey = '<api_key>'

const client = createClient(url, apikey)

const channel = client.channel('room_1', {
  config: { private: true },
})

channel
  .on('broadcast', { event: 'test' }, (payload) => console.log(payload))
  .subscribe((status: string, err: any) => {
    if (status === 'SUBSCRIBED') {
      console.log('Connected!')
    } else {
      console.error(err)
    }
  })
```

## Authorize Broadcast read and write

Broadcast is represented by the `extension` field on the `realtime.messages` table.

If a message is a Broadcast message the value of `realtime.messages.extension` will be `broadcast`.

### Broadcast read

To grant users permission to read Broadcast messages on a Channel topic, you must create a policy for `SELECT` operations on `realtime.messages` where `extension` is `broadcast`.

```sql
CREATE POLICY "authenticated user can receive in room"
ON "realtime"."messages"
FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.topic = realtime.topic()
      AND realtime.messages.extension in ['broadcast']
  )
);
```

### Broadcast write

To authorize sending Broadcast messages you'll need to set a policy for `INSERT` where the value of `realtime.messages.extention` is `broadcast`.

```sql
CREATE POLICY "authenticated user can broadcast in room"
ON "realtime"."messages"
FOR INSERT
TO authenticated
WITH CHECK (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.topic = realtime.topic()
      AND realtime.messages.extension in ['broadcast']
  )
);
```

## Authorize Presence read and write

Presnece is also represented by the `extension` field on the `realtime.messages` table.

If a message is a Presence message the value of `realtime.messages.extension` will be `presence`.

### Presence read

Again, here we use a policy for `SELECT` on `realtime.messages` where `realtime.messages.extension` is `presence`.

```sql
CREATE POLICY "authenticated user can listen to Presence changes in room"
ON "realtime"."messages"
FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.topic = realtime.channel_name()
      AND realtime.messages.extension in ['presence']
  )
);
```

### Presence write

To update the Presence status for a user we need to create a policy for `INSERT` on `realtime.messages` where the value of `realtime.messages.extension` is `presence`.

```sql
CREATE POLICY "authenticated user can register presence in room"
ON "realtime"."messages"
FOR INSERT
TO authenticated
WITH CHECK (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.name = realtime.channel_name()
      AND realtime.messages.extension in ['presence']
  )
);
```

## Authorize Presence and Broadcast

We can authorize Presence and Broadcast in two RLS policies by simply including both extensions in our where filter.

### Broadcast and Presence read

Authorize Presence and Broadcast read in one RLS policy.

```sql
CREATE POLICY "authenticated user can listen to Broadcast and Presence messages in room"
ON "realtime"."messages"
FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.topic = realtime.channel_name()
      AND realtime.messages.extension in ['broadcast', 'presence']
  )
);
```

### Broadcast Presence write

Authorize Presence and Broadcast write in one RLS policy.

```sql
CREATE POLICY "authenticated user can send Broadcast and Presence messages in a room"
ON "realtime"."messages"
FOR INSERT
TO authenticated
WITH CHECK (
  EXISTS (
    SELECT
      ru.user_id
    FROM
      rooms_users ru
    WHERE
      ru.user_id = auth.uid()
      AND ru.name = realtime.channel_name()
      AND realtime.messages.extension in ['broadcast', 'presence']
  )
);
```

## Avoid usage with Postgres Changes

Realtime Postgres Changes are separate from Channel authorization.

Postgres Changes with RLS Realtime Channl authorization is backwards compatible with your production application.

## Updating RLS policies

When you change an RLS policy these changes are picked up when a user connects to a Channel.

When a user connects, Realtime queries your database and generates a representation of the permissions for a user for a Channel.

Permissions are cached for the duration of the connection so we don't have to query your database for each Channel message.

RLS policies are re-checked when access tokens are updated on the Channel. Our client libraries default to updating the access token every 30 seconds.

If a user Channel permissions have been updated these changes will be picked up when the access token is sent over the Channel from the client.

If a new access token is never received on the Channel users will be disconnected when the JWT expires.

Make sure to expire your JWTs frequently.
